# Copilot Instructions

- Product: Telegram sales assistant “Alex” built with Flask. Webhook entrypoints live in [api/webhook.py](api/webhook.py) and are run locally via [run.py](run.py); static dashboard assets sit under [static](static).
- Core flow: webhook receives updates → persists/loads user + context via [api/database.py](api/database.py) and [api/database_memory.py](api/database_memory.py) → crafts replies with Gemini in [api/gemini_handler.py](api/gemini_handler.py) (prompt pieces from [api/prompt_loader.py](api/prompt_loader.py) reading [prompts](prompts)) → falls back to keyword logic in [api/responses.py](api/responses.py) + product heuristics in [api/conversation_handler.py](api/conversation_handler.py) and [api/product_data](api/product_data).
- Telegram I/O lives in [api/telegram_handler.py](api/telegram_handler.py); all outbound messages use Markdown parse mode. Inline buttons come from [api/inline_keyboard.py](api/inline_keyboard.py) with `callback_data` shapes like `price:<product>` and `product:<name>`; keep this contract when adding buttons.
- Product catalog is static: prices/specs/keywords/responses/images are in [api/product_data](api/product_data). Use helpers in [api/product_data/utils.py](api/product_data/utils.py) (`detect_product`, `get_product_price`, etc.) instead of reimplementing lookups.
- Memory layers: quick, in-memory context in [api/user_memory.py](api/user_memory.py) (dict per user) and persistent LangChain-compatible history/context in [api/database_memory.py](api/database_memory.py). Update both appropriately if you change conversation state shape.
- Persistence: SQLAlchemy models in [api/models.py](api/models.py); engine/session setup + helper writers in [api/database.py](api/database.py). Default `DATABASE_URL` is SQLite; Postgres URLs need `postgresql://` (handled). Use `init_db()` before serving.
- Analytics: event loggers in [api/analytics.py](api/analytics.py) write to `analytics` + `product_views` tables. Admin REST API is a blueprint in [api/admin_routes.py](api/admin_routes.py) under `/admin/*`, gated by `ADMIN_API_KEY` (header `X-Admin-Key` or `?api_key=`). Dashboard front-end is [static/dashboard.html](static/dashboard.html) + JS/CSS consuming those endpoints.
- Landing: root `GET /` serves redirecting landing page HTML from [api/landing_page.py](api/landing_page.py); `/dashboard` serves the static dashboard file; `/health` is a simple OK.
- Telegram webhook routes are `/`, `/webhook`, and `/api/webhook` (for Vercel). Callback queries are logged via analytics; when sending media, captions use Markdown and `send_media_group` in [api/telegram_handler.py](api/telegram_handler.py).
- Prompt assets are in [prompts/products.txt](prompts/products.txt), [prompts/sales_style.txt](prompts/sales_style.txt), and [prompts/system_prompt.txt](prompts/system_prompt.txt). Update them before adjusting Gemini prompt assembly in [api/gemini_handler.py](api/gemini_handler.py).
- Error handling: webhook wraps top-level exceptions and logs via `log_error` (analytics). If Gemini fails or no `GOOGLE_API_KEY`, the system falls back to deterministic keyword responses in [api/responses.py](api/responses.py).
- Dev commands: `python run.py` to serve locally (prints dashboard URL); `python api/manage_db.py init|check|stats|reset` for DB lifecycle; `python test_api.py` to validate Gemini key; `python test_bot.py` to exercise conversation/memory/inline keyboards; `python test_flask.py` spins a minimal test server; `python test_data_generator.py` seeds analytics for dashboard.
- Environment: `.env` should provide `TELEGRAM_TOKEN`, `GOOGLE_API_KEY`, `ADMIN_API_KEY`, optional `DATABASE_URL`. Without `TELEGRAM_TOKEN`, webhook returns 500. Keep secrets out of commits.
- Frontend dashboard fetches `/admin/dashboard`, `/admin/analytics/*` using the admin key; see [static/js/dashboard.js](static/js/dashboard.js) for request shapes if you change API responses.
- Imports often try relative then absolute; keep module paths stable to avoid dual-import surprises.
- When adding features, prefer using existing helpers (product detection, memory setters, analytics loggers) so buttons, stats, and persistence stay consistent.
